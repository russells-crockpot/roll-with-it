""" The parser file, Automatically generated by TatSu (with some small modifications).
"""
# pylint: skip-file
#
####################################################################################################
#
# CAVEAT UTILITOR
#
# This file was automatically generated by TatSu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.

from __future__ import generator_stop

from tatsu.buffering import Buffer
from tatsu.parsing import Parser as _Parser
from tatsu.parsing import tatsumasu, leftrec, nomemo

KEYWORDS = {
    'not',
    'for',
    'otherwise',
    'every',
    'that',
    'before',
    'do',
    'or',
    'except',
    'restart',
    'and',
    'as',
    'has',
    'then',
    'after',
    'when',
    'if',
    'load',
    'use',
    'at',
    'until',
    'from',
    'into',
    'unless',
    'leave',
}  # type: ignore


class _Tokenizer(Buffer):

    def __init__(self,
                 text,
                 whitespace=None,
                 nameguard=None,
                 comments_re=None,
                 eol_comments_re='\\/\\/.*?$"',
                 ignorecase=None,
                 namechars='',
                 **kwargs):
        super().__init__(text,
                         whitespace=whitespace,
                         nameguard=nameguard,
                         comments_re=comments_re,
                         eol_comments_re=eol_comments_re,
                         ignorecase=ignorecase,
                         namechars=namechars,
                         **kwargs)


class Parser(_Parser):

    def __init__(self,
                 whitespace=None,
                 nameguard=None,
                 comments_re=None,
                 eol_comments_re='\\/\\/.*?$"',
                 ignorecase=None,
                 left_recursion=True,
                 parseinfo=True,
                 keywords=None,
                 namechars='',
                 tokenizercls=_Tokenizer,
                 **kwargs):
        if keywords is None:
            keywords = KEYWORDS
        super().__init__(whitespace=whitespace,
                         nameguard=nameguard,
                         comments_re=comments_re,
                         eol_comments_re=eol_comments_re,
                         ignorecase=ignorecase,
                         left_recursion=left_recursion,
                         parseinfo=parseinfo,
                         keywords=keywords,
                         namechars=namechars,
                         tokenizercls=tokenizercls,
                         **kwargs)

    @tatsumasu()
    @nomemo
    def _start_(self):  # noqa

        def block0():
            self._statement_()

        self._closure(block0)
        self._check_eof()

    @tatsumasu()
    def _statement_end_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('\n')
            with self._option():
                self._token('\r')
            with self._option():
                self._token('|')
            self._error('expecting one of: \n \r |')

    @tatsumasu()
    @nomemo
    def _statement_(self):  # noqa
        with self._choice():
            with self._option():
                with self._choice():
                    with self._option():
                        self._token('\n')
                    with self._option():
                        self._token('\r')
                    with self._option():
                        self._token('|')
                    self._error('expecting one of: \n \r |')
            with self._option():
                self._basic_statement_()
                self.name_last_node('@')
            self._error(
                'expecting one of: \n \r ! /[a-zA-Z_][a-zA-Z_0-9]*/ ? [ access basic_name basic_statement expression for if leave modify name restart until use_if | ~'
            )

    @tatsumasu()
    def _basic_name_(self):  # noqa
        self._pattern('[a-zA-Z_][a-zA-Z_0-9]*')
        self._check_name()

    @tatsumasu()
    def _name_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('?')
            with self._option():
                self._token('~')
            with self._option():
                self._token('!')
            with self._option():
                self._basic_name_()
            self._error('expecting one of: ! /[a-zA-Z_][a-zA-Z_0-9]*/ ? basic_name ~')
        self._check_name()

    @tatsumasu()
    def _comp_op_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('==')
            with self._option():
                self._token('>=')
            with self._option():
                self._token('<=')
            with self._option():
                self._token('!=')
            with self._option():
                self._token('<')
            with self._option():
                self._token('>')
            with self._option():
                self._token('has')
                with self._ifnot():
                    self._token('do')
            with self._option():
                self._token('and')
            with self._option():
                self._token('or')
            self._error('expecting one of: != < <= == > >= and has or')

    @tatsumasu()
    def _float_(self):  # noqa
        self._pattern('-?\\d*\\.\\d+')

    @tatsumasu()
    def _int_(self):  # noqa
        self._pattern('-?\\d+')

    @tatsumasu()
    def _number_(self):  # noqa
        with self._choice():
            with self._option():
                self._float_()
            with self._option():
                self._int_()
            self._error('expecting one of: /-?\\d*\\.\\d+/ /-?\\d+/ float int')

    @tatsumasu()
    def _if_body_(self):  # noqa
        self._conditional_()
        self.name_last_node('predicate')
        self._token('then')
        self._statement_()
        self.name_last_node('then')

        def block3():
            self._token('unless')
            self._cut()
            self._conditional_()
            self.name_last_node('predicate')
            self._token('then')
            self._statement_()
            self.name_last_node('then')

        self._closure(block3)
        self.name_last_node('unless')
        with self._optional():
            self._token('otherwise')
            self._statement_()
            self.name_last_node('otherwise')
        self.ast._define(['otherwise', 'predicate', 'then', 'unless'], [])

    @tatsumasu()
    def _until_do_body_(self):  # noqa
        with self._optional():
            with self._group():
                self._token('@')
                self._basic_name_()
                self.name_last_node('name')
        self._conditional_()
        self.name_last_node('until')
        self._token('do')
        self._statement_()
        self.name_last_node('do')

        def block4():
            self._token('except')
            self._cut()
            self._token('when')
            self._conditional_()
            self._token('then')
            self._statement_()

        self._closure(block4)
        self.name_last_node('except_when')
        with self._optional():
            self._token('otherwise')
            self._cut()
            self._statement_()
            self.name_last_node('otherwise')
        self.ast._define(['do', 'except_when', 'name', 'otherwise', 'until'], [])

    @tatsumasu()
    def _for_every_body_(self):  # noqa
        with self._optional():
            with self._group():
                self._token('@')
                self._basic_name_()
                self.name_last_node('name')
        with self._optional():
            self._basic_name_()
        self.name_last_node('item_name')
        self._token('that')
        self._cut()
        self._expression_()
        self.name_last_node('iterable')
        self._token('has')
        self._token('do')
        self._statement_()
        self.name_last_node('do')
        self.ast._define(['do', 'item_name', 'iterable', 'name'], [])

    @tatsumasu()
    def _accessor_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('.')
                self._cut()
                self._basic_name_()
                self.name_last_node('@')
            with self._option():
                self._enlarge_reduce_()
            self._error('expecting one of: . enlarge_reduce { {}')

    @tatsumasu()
    @nomemo
    def _access_(self):  # noqa
        with self._choice():
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._name_()
                        with self._option():
                            self._modify_()
                        self._error('expecting one of: modify name')
                self.name_last_node('accessing')

                def block3():
                    self._accessor_()

                self._positive_closure(block3)
                self.name_last_node('accessors')
            with self._option():
                self._name_()
            self._error(
                'expecting one of: ! /[a-zA-Z_][a-zA-Z_0-9]*/ ? access_expr basic_name dice modify name ~'
            )
        self.ast._define(['accessing', 'accessors'], [])

    @tatsumasu()
    def _access_list_(self):  # noqa

        def sep0():
            self._token(',')

        def block0():
            self._access_()

        self._positive_gather(block0, sep0)

    @tatsumasu()
    def _load_body_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('load')
                self._token('*')
                self.name_last_node('to_load')
                self._cut()
                self._token('from')
                self._cut()
                with self._group():

                    def sep2():
                        self._token(',')

                    def block2():
                        self._access_()

                    self._positive_gather(block2, sep2)
                self.name_last_node('load_from')
                with self._optional():
                    self._token('into')
                    self._cut()
                    self._access_()
                    self.name_last_node('into')
            with self._option():
                self._token('load')
                self._token('!')
                self.name_last_node('to_load')
                self._cut()
                self._token('into')
                self._cut()
                with self._group():

                    def sep6():
                        self._token(',')

                    def block6():
                        self._access_()

                    self._positive_gather(block6, sep6)
                self.name_last_node('into')
            with self._option():
                self._token('load')
                with self._group():

                    def sep8():
                        self._token(',')

                    def block8():
                        self._basic_name_()

                    self._positive_gather(block8, sep8)
                self.name_last_node('to_load')
                self._token('from')
                self._cut()
                self._access_()
                self.name_last_node('load_from')
                with self._optional():
                    self._token('into')
                    self._cut()
                    self._access_()
                    self.name_last_node('into')
            with self._option():
                self._token('load')
                with self._group():

                    def sep12():
                        self._token(',')

                    def block12():
                        self._basic_name_()

                    self._positive_gather(block12, sep12)
                self.name_last_node('load_from')
                with self._optional():
                    self._token('into')
                    self._cut()
                    self._access_()
                    self.name_last_node('into')
                self._constant('')
                self.name_last_node('to_load')
            with self._option():
                self._token('load')
                with self._group():

                    def sep16():
                        self._token(',')

                    def block16():
                        self._basic_name_()

                    self._positive_gather(block16, sep16)
                self.name_last_node('to_load')
            self._error('expecting one of: load')
        self.ast._define(['into', 'load_from', 'to_load'], [])

    @tatsumasu()
    def _modifier_args_(self):  # noqa
        self._token('(')

        def sep1():
            self._token(',')

        def block1():
            self._expression_()

        self._gather(block1, sep1)
        self.name_last_node('@')
        with self._optional():
            self._token(',')
        self._token(')')

    @tatsumasu()
    def _enlarge_(self):  # noqa
        with self._optional():
            self._expression_()
        self.name_last_node('size')
        self._token('@')
        with self._optional():
            self._expression_()
        self.name_last_node('value')
        self.ast._define(['size', 'value'], [])

    @tatsumasu()
    def _enlarge_reduce_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('{}')
                self._constant('')
                self.name_last_node('@')
            with self._option():
                self._token('{')
                self._cut()
                with self._group():
                    with self._choice():
                        with self._option():
                            self._enlarge_()
                        with self._option():
                            self._expression_()
                        with self._option():
                            self._token('*')
                        self._error('expecting one of: * enlarge expression')
                self.name_last_node('@')
                self._token('}')
            self._error('expecting one of: { {}')

    @tatsumasu()
    @nomemo
    def _expression_(self):  # noqa
        self._use_if_()

    @tatsumasu()
    @nomemo
    def _use_if_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('use')
                self._cut()
                self._expression_()
                self.name_last_node('use')
                self._token('if')
                self._conditional_()
                self.name_last_node('predicate')
                self._token('otherwise')
                self._expression_()
                self.name_last_node('otherwise')
            with self._option():
                self._conditional_()
            self._error('expecting one of: comparison conditional not use')
        self.ast._define(['otherwise', 'predicate', 'use'], [])

    @tatsumasu()
    @nomemo
    def _conditional_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('not')
                self._cut()
                self._conditional_()
            with self._option():
                self._comparison_()
            self._error('expecting one of: comparison math not')

    @tatsumasu()
    @leftrec
    def _comparison_(self):  # noqa
        with self._choice():
            with self._option():
                self._comparison_()
                self.name_last_node('left')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('==')
                        with self._option():
                            self._token('>=')
                        with self._option():
                            self._token('<=')
                        with self._option():
                            self._token('!=')
                        with self._option():
                            self._token('<')
                        with self._option():
                            self._token('>')
                        with self._option():
                            self._token('has')
                            with self._ifnot():
                                self._token('do')
                        with self._option():
                            self._token('and')
                        with self._option():
                            self._token('or')
                        self._error('expecting one of: != < <= == > >= and has or')
                self.name_last_node('op')
                self._cut()
                self._expression_()
                self.name_last_node('right')
            with self._option():
                self._math_()
            self._error('expecting one of: comparison math roll_math')
        self.ast._define(['left', 'op', 'right'], [])

    @tatsumasu()
    @leftrec
    def _math_(self):  # noqa
        with self._choice():
            with self._option():
                self._math_()
                self.name_last_node('left')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('+')
                        with self._option():
                            self._token('-')
                        self._error('expecting one of: + -')
                self.name_last_node('op')
                self._cut()
                self._math_()
                self.name_last_node('right')
            with self._option():
                self._roll_math_()
                self.name_last_node('left')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('*')
                        with self._option():
                            self._token('//')
                        with self._option():
                            self._token('/')
                        with self._option():
                            self._token('%')
                        self._error('expecting one of: % * / //')
                self.name_last_node('op')
                self._cut()
                self._roll_math_()
                self.name_last_node('right')
            with self._option():
                self._roll_math_()
            self._error('expecting one of: length math roll_math')
        self.ast._define(['left', 'op', 'right'], [])

    @tatsumasu()
    @leftrec
    def _roll_math_(self):  # noqa
        with self._choice():
            with self._option():
                self._roll_math_()
                self.name_last_node('left')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('&')
                        with self._option():
                            self._token('^')
                        self._error('expecting one of: & ^')
                self.name_last_node('op')
                self._cut()
                self._expression_()
                self.name_last_node('right')
            with self._option():
                self._length_()
            self._error('expecting one of: # length modify roll_math')
        self.ast._define(['left', 'op', 'right'], [])

    @tatsumasu()
    def _length_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('#')
                self._cut()
                self._length_()
            with self._option():
                self._modify_()
            self._error('expecting one of: # access_expr modify')

    @tatsumasu()
    @leftrec
    def _modify_(self):  # noqa
        with self._choice():
            with self._option():
                self._modify_()
                self.name_last_node('subject')
                self._token('->')
                self._cut()
                with self._group():
                    with self._choice():
                        with self._option():
                            self._basic_name_()
                        with self._option():
                            self._enlarge_reduce_()
                        self._error('expecting one of: basic_name enlarge_reduce')
                self.name_last_node('modifier')
                with self._optional():
                    self._modifier_args_()
                    self.name_last_node('args')
            with self._option():
                self._access_expr_()
            self._error(
                'expecting one of: ! /[a-zA-Z_][a-zA-Z_0-9]*/ ? access_expr basic_name dice modify name ~'
            )
        self.ast._define(['args', 'modifier', 'subject'], [])

    @tatsumasu()
    @nomemo
    def _access_expr_(self):  # noqa
        with self._choice():
            with self._option():
                with self._choice():
                    with self._option():
                        with self._group():
                            with self._choice():
                                with self._option():
                                    self._name_()
                                with self._option():
                                    self._modify_()
                                self._error('expecting one of: modify name')
                        self.name_last_node('accessing')

                        def block3():
                            self._accessor_()

                        self._positive_closure(block3)
                        self.name_last_node('accessors')
                    with self._option():
                        self._name_()
                    self._error(
                        'expecting one of: ! /[a-zA-Z_][a-zA-Z_0-9]*/ ? access_expr basic_name dice modify name ~'
                    )
            with self._option():
                self._dice_()
            self._error(
                'expecting one of: ! /[a-zA-Z_][a-zA-Z_0-9]*/ /d|D/ ? access_expr basic_name dice enlarge_reduce_expr modify name ~'
            )
        self.ast._define(['accessing', 'accessors'], [])

    @tatsumasu()
    def _dice_(self):  # noqa
        with self._choice():
            with self._option():
                with self._optional():
                    self._enlarge_reduce_expr_()
                self.name_last_node('number_of_dice')
                self._pattern('d|D')
                self._cut()
                self._enlarge_reduce_expr_()
                self.name_last_node('sides')
            with self._option():
                self._enlarge_reduce_expr_()
            self._error('expecting one of: /d|D/ enlarge_reduce_expr factor ~')
        self.ast._define(['number_of_dice', 'sides'], [])

    @tatsumasu()
    def _enlarge_reduce_expr_(self):  # noqa
        with self._choice():
            with self._option():
                with self._if():
                    self._token('{')
                self._cut()
                self._enlarge_reduce_()
            with self._option():
                self._factor_()
            self._error('expecting one of: ( atom factor ~')

    @tatsumasu()
    def _factor_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('(')
                self._cut()
                self._expression_()
                self.name_last_node('@')
                self._token(')')
            with self._option():
                self._atom_()
            self._error(
                'expecting one of: ! ( /-?\\d*\\.\\d+/ /-?\\d+/ /[a-zA-Z_][a-zA-Z_0-9]*/ ? atom basic_name float int name number ~'
            )

    @tatsumasu()
    def _atom_(self):  # noqa
        with self._choice():
            with self._option():
                self._number_()
            with self._option():
                self._name_()
            self._error(
                'expecting one of: ! /-?\\d*\\.\\d+/ /-?\\d+/ /[a-zA-Z_][a-zA-Z_0-9]*/ ? basic_name float int name number ~'
            )

    @tatsumasu()
    def _modifier_params_(self):  # noqa
        self._token('(')

        def sep1():
            self._token(',')

        def block1():
            self._name_()

        self._gather(block1, sep1)
        self.name_last_node('@')
        with self._optional():
            self._token(',')
        self._token(')')

    @tatsumasu()
    def _modifier_def_body_(self):  # noqa
        with self._optional():
            self._modifier_params_()
        self.name_last_node('parameters')
        self._statement_()
        self.name_last_node('definition')
        self.ast._define(['definition', 'parameters'], [])

    @tatsumasu()
    def _assign_op_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('=')
            with self._option():
                self._token('+=')
            with self._option():
                self._token('-=')
            with self._option():
                self._token('/=')
            with self._option():
                self._token('//=')
            with self._option():
                self._token('*=')
            with self._option():
                self._token('%=')
            with self._option():
                self._token('^=')
            with self._option():
                self._token('&=')
            self._error('expecting one of: %= &= *= += -= //= /= = ^=')

    @tatsumasu()
    def _modifier_def_(self):  # noqa
        self._access_()
        self.name_last_node('target')
        self._token('<-')
        with self._optional():
            self._modifier_params_()
        self.name_last_node('parameters')
        self._statement_()
        self.name_last_node('definition')
        self.ast._define(['definition', 'parameters', 'target'], [])

    @tatsumasu()
    def _restart_body_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('before')
                self.name_last_node('location_specifier')
                self._cut()
                with self._optional():
                    self._name_()
                    self.name_last_node('target')
            with self._option():
                self._token('at')
                self.name_last_node('location_specifier')
                self._cut()
                with self._optional():
                    self._name_()
                    self.name_last_node('target')
            with self._option():
                self._token('after')
                self.name_last_node('location_specifier')
                self._cut()
                with self._optional():
                    self._name_()
                    self.name_last_node('target')
            self._error('expecting one of: after at before')
        self.ast._define(['location_specifier', 'target'], [])

    @tatsumasu()
    def _assignment_(self):  # noqa
        self._access_()
        self.name_last_node('target')
        with self._group():
            with self._choice():
                with self._option():
                    self._token('=')
                with self._option():
                    self._token('+=')
                with self._option():
                    self._token('-=')
                with self._option():
                    self._token('/=')
                with self._option():
                    self._token('//=')
                with self._option():
                    self._token('*=')
                with self._option():
                    self._token('%=')
                with self._option():
                    self._token('^=')
                with self._option():
                    self._token('&=')
                self._error('expecting one of: %= &= *= += -= //= /= = ^=')
        self.name_last_node('op')
        with self._ifnot():
            self._token('=')
        self._cut()
        self._expression_()
        self.name_last_node('value')
        self.ast._define(['op', 'target', 'value'], [])

    @tatsumasu()
    @nomemo
    def _basic_statement_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('if')
                self._cut()
                self._if_body_()
                self.name_last_node('@')
            with self._option():
                with self._if():
                    self._token('load')
                self._cut()
                self._load_body_()
                self.name_last_node('@')
            with self._option():
                self._access_()
                self.name_last_node('target')
                self._token('<-')
                self._cut()
                with self._optional():
                    self._modifier_params_()
                self.name_last_node('parameters')
                self._statement_()
                self.name_last_node('definition')
            with self._option():
                self._token('until')
                self._cut()
                self._until_do_body_()
                self.name_last_node('@')
            with self._option():
                self._token('for')
                self._token('every')
                self._cut()
                self._for_every_body_()
                self.name_last_node('@')
            with self._option():
                self._access_()
                self.name_last_node('target')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('=')
                        with self._option():
                            self._token('+=')
                        with self._option():
                            self._token('-=')
                        with self._option():
                            self._token('/=')
                        with self._option():
                            self._token('//=')
                        with self._option():
                            self._token('*=')
                        with self._option():
                            self._token('%=')
                        with self._option():
                            self._token('^=')
                        with self._option():
                            self._token('&=')
                        self._error('expecting one of: %= &= *= += -= //= /= = ^=')
                self.name_last_node('op')
                with self._ifnot():
                    self._token('=')
                self._cut()
                self._expression_()
                self.name_last_node('value')
            with self._option():
                self._token('restart')
                self._cut()
                self._restart_body_()
            with self._option():
                self._token('leave')
            with self._option():
                self._expression_()
            with self._option():
                self._token('[')
                self._cut()

                def block12():
                    self._statement_()

                self._closure(block12)
                self.name_last_node('@')
                self._token(']')
            self._error(
                'expecting one of: ! /[a-zA-Z_][a-zA-Z_0-9]*/ ? [ access access_expr basic_name conditional expression for if leave modify name restart until use use_if ~'
            )
        self.ast._define(['definition', 'op', 'parameters', 'target', 'value'], [])
