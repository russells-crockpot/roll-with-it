""" The parser file, Automatically generated by TatSu (with some small modifications).
"""
# pylint: disable=missing-docstring,protected-access,abstract-method
# pylint: disable=line-too-long,too-many-arguments
# CAVEAT UTILITOR
#
# This file was automatically generated by TatSu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.

from __future__ import generator_stop

from tatsu.buffering import Buffer
from tatsu.parsing import Parser as _Parser
from tatsu.parsing import tatsumasu, leftrec, nomemo

KEYWORDS = {
    'until',
    'elif',
    'if',
    'macro',
    'else',
    'while',
    'result',
    'and',
    'define',
    'for',
    'float',
    'modifier',
    'dice',
    'number',
    'when',
    'clear',
    'int',
    'not',
    'do',
    'in',
    'use',
    'or',
    'die',
    'roll',
}  # type: ignore


class _Tokenizer(Buffer):

    def __init__(self,
                 text,
                 whitespace=None,
                 nameguard=None,
                 comments_re=None,
                 eol_comments_re='\\/\\/.*?$"',
                 ignorecase=None,
                 namechars='',
                 **kwargs):
        super().__init__(text,
                         whitespace=whitespace,
                         nameguard=nameguard,
                         comments_re=comments_re,
                         eol_comments_re=eol_comments_re,
                         ignorecase=ignorecase,
                         namechars=namechars,
                         **kwargs)


class Parser(_Parser):

    def __init__(self,
                 whitespace=None,
                 nameguard=None,
                 comments_re=None,
                 eol_comments_re='\\/\\/.*?$"',
                 ignorecase=None,
                 left_recursion=True,
                 parseinfo=True,
                 keywords=None,
                 namechars='',
                 tokenizercls=_Tokenizer,
                 **kwargs):
        if keywords is None:
            keywords = KEYWORDS
        super().__init__(whitespace=whitespace,
                         nameguard=nameguard,
                         comments_re=comments_re,
                         eol_comments_re=eol_comments_re,
                         ignorecase=ignorecase,
                         left_recursion=left_recursion,
                         parseinfo=parseinfo,
                         keywords=keywords,
                         namechars=namechars,
                         tokenizercls=tokenizercls,
                         **kwargs)

    @tatsumasu()
    @nomemo
    def _start_(self):  # noqa

        def block0():
            self._statement_()

        self._closure(block0)
        self._check_eof()

    @tatsumasu('IGNORE')
    def _NAME_(self):  # noqa
        self._pattern('[a-zA-Z_][a-zA-Z_0-9]*')
        self._check_name()

    @tatsumasu('IGNORE')
    def _KEBAB_NAME_(self):  # noqa
        self._pattern('[a-zA-Z_]([\\-a-zA-Z_0-9]*[\\-a-zA-Z_0-9])?')
        self._check_name()

    @tatsumasu('pybuiltin_float')
    def _FLOAT_(self):  # noqa
        self._pattern('-?\\d*\\.\\d+')

    @tatsumasu('pybuiltin_int')
    def _INT_(self):  # noqa
        self._pattern('-?\\d+')

    @tatsumasu('IGNORE')
    def _NUMBER_(self):  # noqa
        with self._choice():
            with self._option():
                self._FLOAT_()
            with self._option():
                self._INT_()
            self._error('expecting one of: /-?\\d*\\.\\d+/ /-?\\d+/ FLOAT INT')

    @tatsumasu('IGNORE')
    def _modifier_args_(self):  # noqa
        self._token('(')

        def sep0():
            self._token(',')

        def block0():
            self._expression_()
            self.add_last_node_to_name('@')

        self._join(block0, sep0)
        self._token(')')

    @tatsumasu('IGNORE')
    def _DIALECT_NAME_(self):  # noqa
        with self._choice():
            with self._option():
                self._KEBAB_NAME_()
            with self._option():
                self._token('~')
            with self._option():
                self._token('^')
            self._error(
                'expecting one of: /[a-zA-Z_]([\\-a-zA-Z_0-9]*[\\-a-zA-Z_0-9])?/ KEBAB_NAME ^ ~')

    @tatsumasu('IGNORE')
    def _dialect_def_(self):  # noqa
        with self._choice():
            with self._option():
                self._DIALECT_NAME_()
                self.name_last_node('name')
                with self._optional():
                    self._token('(')
                    with self._optional():
                        self._DIALECT_NAME_()
                    self.name_last_node('parent')
                    self._token(')')
            with self._option():
                with self._optional():
                    self._DIALECT_NAME_()
                self.name_last_node('name')
                self._token('(')
                self._DIALECT_NAME_()
                self.name_last_node('parent')
                self._token(')')
            self._error(
                'expecting one of: ( /[a-zA-Z_]([\\-a-zA-Z_0-9]*[\\-a-zA-Z_0-9])?/ DIALECT_NAME KEBAB_NAME ^ ~'
            )
        self.ast._define(['name', 'parent'], [])

    @tatsumasu('Use')
    def _switch_dialect_(self):  # noqa
        self._token('use')
        self._cut()
        self._dialect_def_()
        self.name_last_node('@')

    @tatsumasu('MacroCall')
    def _macro_(self):  # noqa
        self._token('macro')
        self._cut()
        self._KEBAB_NAME_()
        self.name_last_node('name')

        def sep2():
            self._token(',')

        def block2():
            self._pattern('[^,]*')
            self.add_last_node_to_name('@')

        self._join(block2, sep2)
        self.name_last_node('args')
        self.ast._define(['args', 'name'], [])

    @tatsumasu('ModifierCall')
    def _modifier_call_(self):  # noqa
        self._token('->')
        self._cut()
        self._pack_expr_()
        self.name_last_node('name')
        with self._optional():
            self._modifier_args_()
        self.name_last_node('args')
        self.ast._define(['args', 'name'], [])

    @tatsumasu('Modify')
    def _modify_(self):  # noqa
        self._pack_expr_()
        self.name_last_node('modifying')

        def block2():
            self._modifier_call_()

        self._positive_closure(block2)
        self.name_last_node('modifiers')
        self.ast._define(['modifiers', 'modifying'], [])

    @tatsumasu('Dice')
    def _dice_(self):  # noqa
        with self._optional():
            self._factor_()
        self.name_last_node('number_of_dice')
        self._pattern('d|D')
        self._factor_()
        self.name_last_node('sides')
        self.ast._define(['number_of_dice', 'sides'], [])

    @tatsumasu('Pack')
    def _pack_(self):  # noqa
        with self._optional():
            self._dice_expr_()
        self.name_last_node('times')
        self._token('@')
        self._cut()
        self._expression_()
        self.name_last_node('packed')
        self.ast._define(['packed', 'times'], [])

    @tatsumasu('Length')
    def _length_(self):  # noqa
        self._token('#')
        self._cut()
        self._unary_expr_()
        self.name_last_node('value')
        self.ast._define(['value'], [])

    @tatsumasu('Freeze')
    def _freeze_(self):  # noqa
        self._token('!')
        self._cut()
        self._unary_expr_()
        self.name_last_node('value')
        self.ast._define(['value'], [])

    @tatsumasu('Roll')
    def _roll_(self):  # noqa
        self._token('roll')
        self._cut()
        self._expression_()
        self.name_last_node('value')
        self.ast._define(['value'], [])

    @tatsumasu('IGNORE')
    @leftrec
    def _expression_(self):  # noqa
        self._roll_expr_()

    @tatsumasu('IGNORE')
    @nomemo
    def _roll_expr_(self):  # noqa
        with self._choice():
            with self._option():
                self._roll_()
            with self._option():
                self._math_()
            self._error('expecting one of: expression math roll roll_expr term')

    @tatsumasu('Math')
    @nomemo
    def _math_(self):  # noqa
        with self._choice():
            with self._option():
                self._expression_()
                self.name_last_node('left')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('+')
                        with self._option():
                            self._token('-')
                        self._error('expecting one of: + -')
                self.name_last_node('op')
                self._term_()
                self.name_last_node('right')
            with self._option():
                self._term_()
            self._error('expecting one of: expression math roll roll_expr term unary_expr')
        self.ast._define(['left', 'op', 'right'], [])

    @tatsumasu('Math')
    @nomemo
    def _term_(self):  # noqa
        with self._choice():
            with self._option():
                self._expression_()
                self.name_last_node('left')
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('*')
                        with self._option():
                            self._token('/')
                        with self._option():
                            self._token('//')
                        self._error('expecting one of: * / //')
                self.name_last_node('op')
                self._modify_expr_()
                self.name_last_node('right')
            with self._option():
                self._unary_expr_()
            self._error(
                'expecting one of: ! # expression freeze length math modify_expr roll roll_expr unary_expr'
            )
        self.ast._define(['left', 'op', 'right'], [])

    @tatsumasu('IGNORE')
    def _unary_expr_(self):  # noqa
        with self._choice():
            with self._option():
                self._length_()
            with self._option():
                self._freeze_()
            with self._option():
                self._modify_expr_()
            self._error('expecting one of: ! # freeze length modify modify_expr pack_expr')

    @tatsumasu('IGNORE')
    def _modify_expr_(self):  # noqa
        with self._choice():
            with self._option():
                self._modify_()
            with self._option():
                self._pack_expr_()
            self._error('expecting one of: @ dice_expr modify pack pack_expr')

    @tatsumasu('IGNORE')
    def _pack_expr_(self):  # noqa
        with self._choice():
            with self._option():
                self._pack_()
            with self._option():
                self._dice_expr_()
            self._error('expecting one of: /d|D/ @ dice dice_expr factor pack')

    @tatsumasu('IGNORE')
    def _dice_expr_(self):  # noqa
        with self._choice():
            with self._option():
                self._dice_()
            with self._option():
                self._factor_()
            self._error('expecting one of: ! # ( /d|D/ atom dice factor freeze length')

    @tatsumasu('IGNORE')
    def _factor_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('(')
                self._expression_()
                self.name_last_node('@')
                self._token(')')
            with self._option():
                self._freeze_()
            with self._option():
                self._length_()
            with self._option():
                self._atom_()
            self._error(
                'expecting one of: ! # ( /-?\\d*\\.\\d+/ /-?\\d+/ /[a-zA-Z_][a-zA-Z_0-9]*/ FLOAT INT NAME NUMBER atom freeze length reference'
            )

    @tatsumasu('Reference')
    def _reference_(self):  # noqa
        self._NAME_()

    @tatsumasu('IGNORE')
    def _atom_(self):  # noqa
        with self._choice():
            with self._option():
                self._NUMBER_()
            with self._option():
                self._reference_()
            self._error(
                'expecting one of: /-?\\d*\\.\\d+/ /-?\\d+/ /[a-zA-Z_][a-zA-Z_0-9]*/ FLOAT INT NAME NUMBER reference'
            )

    @tatsumasu('Assignment')
    def _assignment_(self):  # noqa
        self._NAME_()
        self.name_last_node('name')
        self._token('=')
        self._expression_()
        self.name_last_node('value')
        self.ast._define(['name', 'value'], [])

    @tatsumasu('IGNORE')
    @nomemo
    def _statement_(self):  # noqa
        with self._choice():
            with self._option():
                self._assignment_()
            with self._option():
                self._expression_()
            with self._option():
                self._switch_dialect_()
            with self._option():
                self._macro_()
            self._error(
                'expecting one of: /[a-zA-Z_][a-zA-Z_0-9]*/ NAME assignment expression macro math roll roll_expr switch_dialect use'
            )
