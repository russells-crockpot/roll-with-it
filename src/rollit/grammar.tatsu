@@grammar::rollit
@@eol_comments:: /\/\/.*?$/
@@keyword:: use if then for do until and or not load from has leave
@@keyword:: otherwise unless into except when for every that
@@keyword:: at after restart before
@@left_recursion:: True
@@parseinfo:: False

start = {@:statement (STATEMENT_END | $)};

SPACES = /[ \t]+/;
LINE_JOINING = '%>' [>SPACES] /[\n\r\f]/;

STATEMENT_END = /[\n\r\f|]+/;


# By having the escape sequences all be in a seperate regex, we're able to seperate (and replace)
# them easily when building the model
string = "'" @:{/\\[\\runftvb']/ | /[^\\']+/} "'" ;

@name
basic_name = /[a-zA-Z_][a-zA-Z_0-9]*/;

@name
name =  '$' | '?' | '~' | '!' | basic_name;


comp_op =
    | '=='
    | '>='
    | '<='
    | '!='
    | '<'
    | '>'
    | 'has' !'do'
    | 'and'
    | 'or'
    ;

float = /-?\d*\.\d+/ ;

int = /-?\d+/ ;

number = float | int;

if_body
    =
    predicate:expression 'then' then:statement
    unless:{'unless' ~ predicate:expression 'then' then:statement}
    ['otherwise' otherwise:statement];

# Loops
until_do_body
    = [('@' name:basic_name)] until:expression 'do' do:statement
      except_when:{'except' ~ 'when' expression 'then' statement}
      ['otherwise' ~ otherwise:statement]
    ;

for_every_body
    = [('@' name:basic_name)] item_name:[basic_name]
      'that' ~ iterable:expression 'has' 'do' do:statement;

accessor
    =
    | '.' ~ @:basic_name
    | enlarge_reduce
    ;

accessable = name | enlarge_reduce | modify ;

access
    =
    | accessing:(accessable) accessors:{accessor}+
    | name
    ;

access_list = ','.{access}+ ;

load_body
    =
    | 'load' to_load:'*' ~ 'from' ~ load_from:(>access_list) ['into' ~ into:access]
    | 'load' to_load:'!' ~ 'into' ~ into:(>access_list)
    | 'load' to_load:(','.{basic_name}+) 'from' ~ load_from:access ['into' ~ into:access]
    | 'load' load_from:(','.{basic_name}+) ['into' ~ into:access] to_load:`''`
    | 'load' to_load:(','.{basic_name}+)
    ;

modifier_args = '(' @:','.{ expression } [','] ')';

enlarge = size:[expression] '@' value:[expression];

enlarge_reduce
    =
    | '{}' @:`''`
    | '{'~ @:(enlarge | expression | '*') '}'
    ;

expression = use_if;

use_if
    =
    | 'use' ~ use:expression 'if' predicate:comparison 'otherwise' otherwise:expression
    | 'not' ~ comparison
    | comparison
    ;

comparison
    =
    | left:comparison op:(>comp_op) ~ right:comparison
    | left:comparison op:('&' | '^') !'=' ~ right:math
    | math
    ;

mult_op = '*' | '%/' | '/' | '%' !'>';

math
    =
    | left:math op:('+'|'-') !'=' ~ right:math
    | left:math op:(>mult_op) !'=' ~ right:modify
    | '#' ~ modify
    | modify
    ;

modify
    =
    | subject:modify  '->' ~ modifier:(basic_name|enlarge_reduce) [args:modifier_args]
    | number_of_dice:[enlarge_reduce_expr] /d|D/ ~ sides:enlarge_reduce_expr
    | >access
    | enlarge_reduce_expr
    ;

enlarge_reduce_expr
    =
    | &'{' ~ enlarge_reduce
    | factor
    ;

factor
    =
    | '(' ~ @:expression ')'
    | atom
    ;

atom
    =
    | number
    | name
    | string
    ;

modifier_params = '(' @:','.{ name } [','] ')';

modifier_def_body =  parameters:[modifier_params] definition:statement ;

assign_op
    =
    | '='
    | '+='
    | '-='
    | '/='
    | '%/='
    | '*='
    | '%='
    | '^='
    | '&='
    ;

modifier_def = target:access '<-' parameters:[modifier_params] definition:statement;

restart_body
    =
    | location_specifier:'before' ~ [target:name]
    | location_specifier:'at' ~ [target:name]
    | location_specifier:'after' ~ [target:name]
    ;

assignment = target:access op:(>assign_op) !'=' ~ value:expression;

statement
    =
    #| target:access '<-' ~
      #parameters:[modifier_params]
      #modifier_def_start definition:statement modifier_def_end
    #| >assignment
    | expression
    | 'if' ~ @:if_body
    | 'until' ~ @:until_do_body
    | 'for' ~ 'every' @:for_every_body
    | 'restart' ~ restart_body
    | 'leave' ~
    | '[' ~ @:{statement} ']'
    | &'load' ~ @:load_body
    ;

modifier_def_start = ();
modifier_def_end = ();
