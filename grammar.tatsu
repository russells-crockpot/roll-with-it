@@grammar::RollIt
@@eol_comments:: /\/\/.*?$"/
@@keyword:: use roll if then when while for do until and or not define
@@keyword:: int float number clear load as from has
@@keyword:: otherwise skip unless continue

#start = load $;

start = {statement} $;

statement::statement
    =
    | @:basic_statement
    | /[\n\r]+/
    | '|'
    ;

@name
NAME::IGNORE
    = /[a-zA-Z_][a-zA-Z_0-9]*/;

@name
KEBAB_NAME::IGNORE
    = /[a-zA-Z_]([\-a-zA-Z_0-9]*[\-a-zA-Z_0-9])?/ ;

COMP_OP::IGNORE
    =
    | '<'
    | '>'
    | '=='
    | '>='
    | '<='
    | '!='
    | 'has'
    ;

FLOAT::pybuiltin_float
    = /-?\d*\.\d+/ ;

INT::pybuiltin_int
    = /-?\d+/ ;

NUMBER::IGNORE
    = FLOAT | INT;

unless::Unless
    = 'unless' ~ predicate:conditional 'then' then:statement;

if_statement::If
    = 'if' ~ predicate:conditional 'then' then:statement
    unless:{&'unless' ~ unless} ['otherwise' otherwise:statement];

# Loops
do_until::DoUntil
    = 'do' do:statement 'until' until:conditional ['otherwise' otherwise:statement];

until_do::UntilDo
    = 'until' until:conditional 'do' do:statement ['otherwise' otherwise:statement];

flow_control::FlowControl
    = 'skip' | 'continue';

dialects_list::IGNORE
    =
    | ','%{ @+:KEBAB_NAME }+
    | '(' ','%{ @+:KEBAB_NAME }+ ')'
    ;

loadables_list::IGNORE
    =
    | '*'
    | ','%{ @+:NAME }+
    | '(' ','%{ @+:NAME }+ ')'
    ;

load::load
    = 'load' to_load:({reference}+ | '*') ['from' ~ from_dialect:(KEBAB_NAME|reference)];

modifier_args::IGNORE
    = '(' ','%{ @+:expression } [','] ')';

modifier_call::ModifierCall
    = '->' modifier:reference args:[modifier_args] ;

length::Length
    = '#' ~ @:access;

reference::Reference
    = NAME | '?';

fill::Fill
    = size:[expression] '@' value:[expression];

roll::Roll
    =
    | '[' !']' ~ value:(fill | expression | '*'| '-')']'
    | '[' &']' ~ value:`'-'` ']'
    ;

accessor::IGNORE
    =
    | '.' @:NAME
    | roll
    ;

negation::Negation
    = 'not' value:conditional;

expression::IGNORE
    = use_if;

use_if::UseIf
    =
    | 'use' ~ use:expression 'if' predicate:conditional 'otherwise' otherwise:expression
    | conditional
    ;

conditional::IGNORE
    =
    | &'not' ~ @:negation
    | comparison
    ;

comparison::Comparison
    =
    | left:comparison op:(>COMP_OP) right:expression
    | roll_math
    ;

# &: combine rolls
# ^: remove x number of dice
roll_math::RollMath
    =
    | right:modify op:('&' | '^') left: expression
    | math
    ;

math::Math
    =
    | left:math op:('+'|'-') ~ right:math
    | left:access op:('*'|'//'|'/') ~ right:access
    | access
    ;

access::Access
    =
    | accessing:modify accessors:{accessor}+
    | unary_expr
    ;

unary_expr::IGNORE
    =
    | &'#' ~ length
    | modify
    ;

modify::Modify
    =
    | modifying:access  &'->' ~ modifiers:{modifier_call}+
    | dice
    ;

dice::Dice
    =
    | number_of_dice:[roll_expr] /d|D/ ~ sides:roll_expr
    | roll_expr
    ;

roll_expr::IGNORE
    =
    | &'[' ~ roll
    | factor
    ;

factor::IGNORE
    =
    | '(' !')' ~ @:expression ')'
    | atom
    ;

atom::IGNORE
    =
    | NUMBER
    | reference
    ;

return::Return
    = '@' @:expression;

#TODO allow assignment to an access
assignment::Assignment
    = name:NAME '=' ~ value:expression ;

modifier_params::IGNORE
    = '(' ','%{ @+:NAME } [','] ')';

#TODO allow assignment to an access
modifier_def::ModifierDef
    = name:NAME '<-' ~ args:[modifier_params] definition:statement ;

basic_statement
    =
    | '{' ~ @:{statement} '}'
    | &'if' ~ if_statement
    | &'load' ~ load
    | >flow_control
    | &(NAME '<-') ~ modifier_def
    | &(NAME '=') ~ assignment
    | &'@' ~ return
    | expression
    ;


