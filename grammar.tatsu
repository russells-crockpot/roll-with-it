@@grammar::RollIt
@@eol_comments:: /\/\/.*?$"/
@@keyword:: use roll if else elif when while for do until and or not in define
@@keyword:: dice die result modifier int float number clear macro load as from

start
    =
     statement $
     #[statement] {STATEMENT_END statement} [STATEMENT_END] $
    ;

STATEMENT_END::IGNORE
    =
    | /[\n\r]+/
    | {'|'}+
    ;

@name
NAME::IGNORE
    = /[a-zA-Z_][a-zA-Z_0-9]*/;

@name
KEBAB_NAME::IGNORE
    = /[a-zA-Z_]([\-a-zA-Z_0-9]*[\-a-zA-Z_0-9])?/ ;

FLOAT::pybuiltin_float
    = /-?\d*\.\d+/ ;

INT::pybuiltin_int
    = /-?\d+/ ;

NUMBER::IGNORE
    =
    | FLOAT
    | INT
    ;

DIALECT_NAME::IGNORE
    =
    | KEBAB_NAME
    | '~'
    | '^'
    ;

dialect_def::IGNORE
    =
    | name:DIALECT_NAME ['(' parent:[DIALECT_NAME] ')']
    | name:[DIALECT_NAME] '(' parent:DIALECT_NAME ')'
    ;

use::Use
    = 'use'  ~ @:dialect_def ;

dialects_list::IGNORE
    =
    | ','%{ @+:KEBAB_NAME }+
    | '(' ','%{ @+:KEBAB_NAME }+ ')'
    ;

loadables_list::IGNORE
    =
    | '*'
    | ','%{ @+:NAME }+
    | '(' ','%{ @+:NAME }+ ')'
    ;

load::Load
    = 'load' dialects:dialects_list;

load_from::LoadFrom
    =
    | 'load' loadables:loadables_list 'from' dialect:KEBAB_NAME
    | load
    ;

macro::MacroCall
    = 'macro' ~ name:KEBAB_NAME args:','%{ /[^,]*/};

modifier_args::IGNORE
    = '(' ','%{ @+:expression } ')';

modifier_call::ModifierCall
    = '->' ~ modifier:reference args:[modifier_args] ;

dice::Dice
    = number_of_dice:[factor] /d|D/ sides:factor ;

length::Length
    = '#' ~ value:unary_expr;

freeze::Freeze
    = '!' ~ value:unary_expr;

reference::Reference
    =
    | NAME
    | '?'
    ;

accessor::Accessor
    =
    | '.' value:NAME
    | '[' value:expression ']'
    ;

expression::IGNORE
    = math;

math::Math
    =
    | left:math op:('+'|'-') right:math
    | left:access op:('*'|'//'|'/') right:access
    | access
    ;

access::Access
    =
    | accessing:pack accessors:{accessor}+
    | pack
    ;

pack::Pack
    =
    | times:[unary_expr] '@' ~ packed:modify
    | modify
    ;


modify::Modify
    =
    | modifying:pack  modifiers:{modifier_call}+
    | roll
    ;


roll::Roll
    =
    | 'roll' ~ value:expression
    | unary_expr
    ;

unary_expr::IGNORE
    =
    | length
    | freeze
    | dice_expr
    ;

dice_expr::IGNORE
    =
    | dice
    | factor
    ;

factor::IGNORE
    =
    | '(' @:expression ')'
    | atom
    ;

atom::IGNORE
    =
    | NUMBER
    | reference
    ;

assignment::Assignment
    = name:NAME '<-' ~ value:expression ;

statement::IGNORE
    =
    | expression
    | assignment
    | use
    | load_from
    #| load
    | macro
    ;
