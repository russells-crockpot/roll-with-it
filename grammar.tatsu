@@grammar::RollIt
@@eol_comments:: /\/\/.*?$"/
@@keyword:: use if then for do until and or not load as from has finish
@@keyword:: otherwise unless into except when for every that
@@keyword:: at after restart before

#start = load $;

start = {statement} $;

statement
    =
    | @:basic_statement
    | /[\n\r]+/
    | '|'
    ;

@name
name = /[a-zA-Z_][a-zA-Z_0-9]*/;

@name
kebab_name = /[a-zA-Z_]([\-a-zA-Z_0-9]*[\-a-zA-Z_0-9])?/ ;

comp_op =
    | '=='
    | '>='
    | '<='
    | '!='
    | '<'
    | '>'
    | 'has'
    | 'and'
    | 'or'
    ;

float = /-?\d*\.\d+/ ;

int = /-?\d+/ ;

number = float | int;

unless = 'unless' predicate:conditional 'then' then:statement;

if_body
    = ~ predicate:conditional 'then' then:statement
    unless:{&'unless' ~ unless} ['otherwise' otherwise:statement];

# Loops
until_do_body
    = [('@' name:name)] until:conditional 'do' do:statement
      except_when:{'except' ~ 'when'  conditional 'then' statement}
      ['otherwise' ~ otherwise:statement]
    ;

for_every_body
    = [('@' name:name)] item_name:name 'that' iterable:expression 'has' 'do' do:statement;

dialect_name = kebab_name | name;

load_body
    = to_load:({dialect_name}+ | '*')
      ['from' ~ from_dialect:(dialect_name)]
      ['into' ~ into:reference]
    ;

modifier_args = '(' @:','.{ expression } [','] ')';

modifier_call = '->' modifier:reference args:[modifier_args] ;

reference = name | '?' | '~' | '!';

enlarge = size:[expression] '@' value:[expression];

reduce_enlarge
    =
    | '{' !'}' ~ @:(enlarge | expression | '*'| '!') '}'
    | '{' &'}' ~ @:`''` '}'
    ;

accessor
    =
    | '.' @:name
    | reduce_enlarge
    ;

expression
    =
    | '()' ~ !()
    | use_if;

use_if
    =
    | 'use' ~ use:expression 'if' predicate:conditional 'otherwise' otherwise:expression
    | conditional
    ;

conditional
    =
    | 'not' ~ conditional
    | comparison
    ;

comparison
    =
    | left:comparison op:(>comp_op) ~ right:expression
    | math
    ;

math
    =
    | left:math op:('+'|'-') ~ right:math
    | left:access op:('*'|'//'|'/' | '%') ~ right:access
    | roll_math
    ;

# &: combine rolls
# ^: remove x number of values
roll_math
    =
    | left:roll_math op:('&' | '^') ~ right: expression
    | length
    ;

length
    =
    | '#' ~ length
    | modify
    ;

modify
    =
    | subject:access  &'->' ~ modifiers:{modifier_call}+
    | access
    ;

access
    =
    | accessing:modify accessors:{accessor}+
    | dice
    ;

dice
    =
    | number_of_dice:[reduce_enlarge_expr] /d|D/ ~ sides:reduce_enlarge_expr
    | reduce_enlarge_expr
    ;

reduce_enlarge_expr
    =
    | &'{' ~ reduce_enlarge
    | factor
    ;

factor
    =
    | '(' !')' ~ @:expression ')'
    | atom
    ;

atom
    =
    | number
    | reference
    ;

modifier_params = '(' @:','.{ reference } [','] ')';

modifier_def_body =  parameters:[modifier_params] definition:statement ;

assign_op
    =
    | '='
    | '+='
    | '-='
    | '/='
    | '//='
    | '*='
    | '%='
    | '^='
    | '&='
    ;

modifier_def = target:access '<-' parameters:[modifier_params] definition:statement;

restart_body
    =
    | location_specifier:'before' ~ [target:(name | '~' | '!')]
    | location_specifier:'at' ~ [target:(name | '~' | '!')]
    | location_specifier:'after' ~ [target:(name | '~' | '!')]
    ;

basic_statement
    =
    | 'if' ~ @:if_body
    | 'load' ~ @:load_body
    | &(access '<-') ~ @:modifier_def
    | 'until' ~ @:until_do_body
    | 'for' 'every' ~ @:for_every_body
    | target:access op:(>assign_op) !'=' ~ value:expression
    | 'restart' ~ restart_body
    | 'finisn'
    | expression
    | '[' ~ @:{statement} ']'
    ;
