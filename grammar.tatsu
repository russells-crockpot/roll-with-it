@@grammar::RollIt
@@eol_comments:: /\/\/.*?$"/
@@keyword:: use roll if else elif when while for do until and or not in define
@@keyword:: dice die result modifier int float number clear macro load as from
@@keyword:: otherwise skip unless

#start = expression $;

start = {statement} $;

statement::statement
    =
    | @:basic_statement
    | /[\n\r]+/
    | '|'
    ;

@name
NAME::IGNORE
    = /[a-zA-Z_][a-zA-Z_0-9]*/;

@name
KEBAB_NAME::IGNORE
    = /[a-zA-Z_]([\-a-zA-Z_0-9]*[\-a-zA-Z_0-9])?/ ;

FLOAT::pybuiltin_float
    = /-?\d*\.\d+/ ;

INT::pybuiltin_int
    = /-?\d+/ ;

NUMBER::IGNORE
    = FLOAT | INT;

return::Return
    = '@' @:expression;

test::Test
    = 'TODO';

use_when::UseWhen
    = 'use'  ~ if_true:expression 'when' predicate:test 'otherwise' if_false:expression;

# Loops
do_until::DoUntil
    = 'do' do:expression 'until' until:test;

until_do::UntilDo
    = 'until' until:test 'do' do:expression;

flow_control::FlowControl
    = 'skip' | 'continue';

dialects_list::IGNORE
    =
    | ','%{ @+:KEBAB_NAME }+
    | '(' ','%{ @+:KEBAB_NAME }+ ')'
    ;

loadables_list::IGNORE
    =
    | '*'
    | ','%{ @+:NAME }+
    | '(' ','%{ @+:NAME }+ ')'
    ;

load::Load
    = 'load' dialects:dialects_list;

load_from::LoadFrom
    = 'load' loadables:loadables_list 'from' dialect:KEBAB_NAME;

modifier_args::IGNORE
    = '(' ','%{ @+:expression } [','] ')';

modifier_call::ModifierCall
    = '->' ~ modifier:reference args:[modifier_args] ;

length::Length
    = '#' ~ @:access;

freeze::Freeze
    = '!' ~ @:access;

reference::Reference
    = NAME | '?';

roll::Roll
    =
    | '[' !']' ~ value:[(expression | '*'| '-')]']'
    | '[' &']' ~ value:`'-'` ']'
    ;

accessor::IGNORE
    =
    | '.' @:NAME
    | roll
    ;

expression::IGNORE
    = math;

math::Math
    =
    | left:math op:('+'|'-') ~ right:math
    | left:access op:('*'|'//'|'/') ~ right:access
    | access
    ;

access::Access
    =
    | accessing:modify accessors:{accessor}+
    | unary_expr
    ;

unary_expr::IGNORE
    =
    | &'#' ~ length
    | &'!' ~ freeze
    | modify
    ;

modify::Modify
    =
    | modifying:access  &'->' ~ modifiers:{modifier_call}+
    | dice
    ;

dice::Dice
    =
    | number_of_dice:[roll_expr] /d|D/ ~ sides:roll_expr
    | block
    ;

block::IGNORE
    =
    | '{' ~ @+:{statement} '}'
    | roll_expr
    ;

roll_expr::IGNORE
    =
    | &'[' ~ roll
    | factor
    ;

factor::IGNORE
    =
    | '(' !')' ~ @:expression ')'
    | atom
    ;

atom::IGNORE
    =
    | NUMBER
    | reference
    ;

#TODO allow assignment to an access
assignment::Assignment
    = name:NAME '<-' ~ value:expression ;

basic_statement
    =
    | expression
    | assignment
    | load_from
    #| load
    ;

