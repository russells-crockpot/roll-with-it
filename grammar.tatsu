@@grammar::RollIt
@@eol_comments:: /\/\/.*?$"/
@@keyword:: use if then for do until and or not clear load as from has
@@keyword:: otherwise skip unless break into except when

#start = load $;

start = {statement} $;

statement::statement
    =
    | @:basic_statement
    | /[\n\r]+/
    | '|'
    ;

@name
NAME::IGNORE
    = /[a-zA-Z_][a-zA-Z_0-9]*/;

@name
KEBAB_NAME::IGNORE
    = /[a-zA-Z_]([\-a-zA-Z_0-9]*[\-a-zA-Z_0-9])?/ ;

COMP_OP::IGNORE
    =
    | '=='
    | '>='
    | '<='
    | '!='
    | '<'
    | '>'
    | 'has'
    ;

FLOAT::pybuiltin_float
    = /-?\d*\.\d+/ ;

INT::pybuiltin_int
    = /-?\d+/ ;

NUMBER::IGNORE
    = FLOAT | INT;

unless::Unless
    = 'unless' predicate:conditional 'then' then:statement;

if_body::If
    = ~ predicate:conditional 'then' then:statement
    unless:{&'unless' ~ unless} ['otherwise' otherwise:statement];

except_when::ExceptWhen
    = 'except when' predicate:conditional 'then' then:statement;

# Loops
do_until_body::DoUntil
    = do:statement 'until' until:conditional
      except_when:{&'except when' ~ except_when}
      ['otherwise' otherwise:statement]
    ;

until_do_body::UntilDo
    = until:conditional 'do' do:statement
      except_when:{&'except when' ~ except_when}
      ['otherwise' otherwise:statement]
    ;

dialect_name = KEBAB_NAME | NAME;

load_body::load
    = to_load:({dialect_name}+ | '*')
      ['from' ~ from_dialect:(dialect_name)]
      ['into' ~ into:reference]
    ;

modifier_args::IGNORE
    = '(' @+:','.{ expression } [','] ')';

modifier_call::ModifierCall
    = '->' modifier:reference args:[modifier_args] ;

reference::Reference
    = NAME | '?' | '~';

enlarge::Enlarge
    = size:[expression] '@' value:[expression];

reduce_enlarge::Reduce
    =
    | '{' !'}' ~ value:(@:enlarge | expression | '*'| '-')'}'
    | '{' &'}' ~ value:`'-'` '}'
    ;

accessor::IGNORE
    =
    | '.' @:NAME
    | reduce_enlarge
    ;

expression::IGNORE
    =
    | '()' ~ !()
    | use_if;

use_if::UseIf
    =
    | 'use' ~ use:expression 'if' predicate:conditional 'otherwise' otherwise:expression
    | conditional
    ;

conditional::IGNORE
    =
    | 'not' ~ conditional
    | comparison
    ;

comparison::Comparison
    =
    | left:comparison op:(>COMP_OP) ~ right:expression
    | math
    ;

math::Math
    =
    | left:math op:('+'|'-') ~ right:math
    | left:access op:('*'|'//'|'/' | '%') ~ right:access
    | roll_math
    ;

# &: combine rolls
# ^: remove x number of dice
roll_math::RollMath
    =
    | left:roll_math op:('&' | '^') ~ right: expression
    | length
    ;

length::Length
    =
    | '#' ~ length
    | modify
    ;

modify::Modify
    =
    | modifying:access  &'->' ~ modifiers:{modifier_call}+
    | access
    ;

access::Access
    =
    | accessing:modify accessors:{accessor}+
    | dice
    ;

dice::Dice
    =
    | number_of_dice:[reduce_enlarge_expr] /d|D/ ~ sides:reduce_enlarge_expr
    | reduce_enlarge_expr
    ;

reduce_enlarge_expr::IGNORE
    =
    | &'{' ~ reduce_enlarge
    | factor
    ;

factor::IGNORE
    =
    | '(' !')' ~ @:expression ')'
    | atom
    ;

atom::IGNORE
    =
    | NUMBER
    | reference
    ;

return_body::Return
    = @:expression;

modifier_params::IGNORE
    = '(' @:','.{ reference } [','] ')';

modifier_def_body::IGNORE
    =  parameters:[modifier_params] definition:statement ;

basic_statement
    =
    | 'if' ~ @:if_body
    | 'load' ~ @:load_body
    | !'#' target:access '<-' ~ body:modifier_def_body _type:`'ModifierDef'`
    | 'do' ~ @:do_until_body
    | 'until' ~ @:until_do_body
    | target:access '=' !'=' ~ value:expression _type:`Assignment`
    | 'skip'
    | 'break'
    | expression
    | '[' ~ @:{statement} ']'
    | '@' ~ return_body
    ;
